<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lecture 21: Map Transitions - CSCI 3213</title>
    
    <!-- OCU Branded Presentation Styles with Theme Support -->
    <link rel="stylesheet" href="../../styles/presentation.css">
    <link rel="icon" type="image/x-icon" href="/images/favicon.png">
    
    <!-- Lecture-Specific Styles -->
    <style>
        .transition-demo {
            background: #1a1a2e;
            color: #0f0;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            border: 2px solid #16213e;
        }
        
        .concept-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .concept-card {
            background: var(--card-bg, #f8f8f8);
            padding: 20px;
            border-radius: 8px;
            border: 2px solid var(--border-color, #ddd);
        }
        
        .code-showcase {
            background: #2d2d2d;
            color: #00ff00;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            border-left: 4px solid #00ff00;
            overflow-x: auto;
        }

        .animation-example {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            gap: 20px;
        }

        .animation-box {
            background: var(--bg-secondary);
            padding: 20px;
            border-radius: 8px;
            flex: 1;
            text-align: center;
            border: 2px solid var(--ocu-cyan);
        }

        .godot-tip {
            background: var(--ocu-cyan);
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 5px solid var(--ocu-true-blue);
        }

        .tree-structure {
            background: #f4f4f4;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            margin: 20px 0;
            border-left: 4px solid var(--ocu-orange);
        }
    </style>
</head>
<body>
    
    <div class="presentation-container">
        <!-- Timer display -->
        <div class="timer-display" id="timer-display">
            <span id="timer-text">Lecture 21: Map Transitions
                 <button class="home"><a href="../../index.html">Home</a></button>
            </span>
        </div>

        <!-- Slide 1: Title -->
        <div class="slide active">
            <h1>Map Transitions</h1>
            <h2>Autoload and Coroutines <span class="emoji">üé≠</span></h2>
            <p style="font-size: 1.5em; margin-top: 40px;">CSCI 3213 - Game Programming</p>
            <p style="font-size: 1.3em;">Spring '26 - Week 21</p>
            <p style="margin-top: auto; font-style: italic;">The curtains close for this map.</p>
        </div>

        <!-- Slide 2: Learning Objectives -->
        <div class="slide">
            <h1>Today's Quest Objectives</h1>
            <ul style="font-size: 1.4em; line-height: 2;">
                <li>üéØ Understand autoload scripts and global state management</li>
                <li>üéØ Create smooth map transitions with animations</li>
                <li>üéØ Master coroutines and the await keyword</li>
                <li>üéØ Implement game pausing during transitions</li>
                <li>üéØ Use threaded resource loading for performance</li>
            </ul>
        </div>

        <!-- Slide 3: The Problem -->
        <div class="slide">
            <h1>The Challenge</h1>
            <h2>Current Map Loading</h2>
            <div class="demo-box">
                <p><strong>Current behavior:</strong></p>
                <ul style="text-align: left; margin: 20px;">
                    <li>Map immediately replaces itself when completed</li>
                    <li>No visual feedback during transition</li>
                    <li>Jarring experience for players</li>
                    <li>No global state management</li>
                </ul>
            </div>
            <div class="godot-tip">
                <strong>Goal:</strong> Add smooth animations and better structure to map transitions
            </div>
        </div>

        <!-- Slide 4: Main Node Script -->
        <div class="slide">
            <h1>Creating a Main Script</h1>
            <h2>Centralizing Map Loading Logic</h2>
            <div class="code-showcase">
extends Node

func load_next_map() -> void:
    var current_map_path := get_tree().current_scene.scene_file_path
    var split_path := current_map_path.split(".")
    var next_map_number := split_path[1].to_int() + 1
    split_path[1] = str(next_map_number).pad_zeros(3)
    var next_map_path = ".".join(split_path)
    
    if not ResourceLoader.exists(next_map_path):
        split_path[1] = "001"
        next_map_path = ".".join(split_path)
    
    get_tree().change_scene_to_file(next_map_path)
            </div>
            <p>Move map loading logic from map.gd to a central main.gd script</p>
        </div>

        <!-- Slide 5: Autoload -->
        <div class="slide">
            <h1>Autoload Scripts</h1>
            <h2>Global Singletons in Godot</h2>
            <div class="concept-grid">
                <div class="concept-card">
                    <h3>üåç What is Autoload?</h3>
                    <p>Scripts that are automatically loaded when the game starts and persist across scene changes</p>
                </div>
                <div class="concept-card">
                    <h3>üìç Setup Location</h3>
                    <p>Project Settings ‚Üí Globals ‚Üí Autoload tab</p>
                </div>
                <div class="concept-card">
                    <h3>üéØ Use Cases</h3>
                    <p>Global state, managers, persistent systems, transition effects</p>
                </div>
                <div class="concept-card">
                    <h3>üîó Access</h3>
                    <p>Via the registered node name (e.g., Main.load_next_map())</p>
                </div>
            </div>
        </div>

        <!-- Slide 6: Autoload Setup -->
        <div class="slide">
            <h1>Setting Up Autoload</h1>
            <h2>Project Settings Configuration</h2>
            <div class="demo-box">
                <p><strong>Steps:</strong></p>
                <ol style="text-align: left; margin: 20px;">
                    <li>Go to Project ‚Üí Project Settings ‚Üí Globals ‚Üí Autoload</li>
                    <li>Select main.gd for Path</li>
                    <li>Set Node Name to "Main"</li>
                    <li>Press + Add</li>
                </ol>
            </div>
            <div class="tree-structure">
Root (Window)
‚îú‚îÄ‚îÄ Main (autoloaded)
‚îî‚îÄ‚îÄ CurrentMap (scene)
            </div>
            <div class="godot-tip">
                <strong>Naming Convention:</strong> Globals use PascalCase (Main, MapTransition)
            </div>
        </div>

        <!-- Slide 7: Using Autoload -->
        <div class="slide">
            <h1>Using the Autoload Script</h1>
            <h2>Calling from Map.gd</h2>
            <div class="code-showcase">
func _on_detector_validity_changed(valid: bool):
    if valid:
        valid_detector_count += 1
        if valid_detector_count == registered_detector_count:
            # Instead of: load_next_map.call_deferred()
            Main.load_next_map()  # Call the global script
    else:
        valid_detector_count -= 1
            </div>
            <p>Access autoloaded scripts via their registered name</p>
        </div>

        <!-- Slide 8: Transition Scene -->
        <div class="slide">
            <h1>Map Transition Scene</h1>
            <h2>Creating the Transition Effect</h2>
            <div class="demo-box">
                <p><strong>Scene Structure:</strong></p>
                <ul style="text-align: left; margin: 20px;">
                    <li>Node root with map_transition.gd script</li>
                    <li>CanvasLayer (Layer 2) for draw order</li>
                    <li>ColorRect (400√ó240) for black screen</li>
                    <li>AnimationPlayer for fade effects</li>
                </ul>
            </div>
            <div class="code-showcase">
extends Node

func play_exit_map() -> void:
    pass

func play_enter_map() -> void:
    pass
            </div>
        </div>

        <!-- Slide 9: Canvas Layers -->
        <div class="slide">
            <h1>Canvas Layers</h1>
            <h2>Controlling Draw Order</h2>
            <div class="animation-example">
                <div class="animation-box">
                    <h3>Layer 0 (Default)</h3>
                    <p>Map draws here</p>
                    <p style="font-size: 2em;">üó∫Ô∏è</p>
                </div>
                <div class="animation-box">
                    <h3>Layer 2</h3>
                    <p>Transition draws here</p>
                    <p style="font-size: 2em;">‚¨õ</p>
                </div>
            </div>
            <div class="godot-tip">
                <strong>Higher layer numbers draw on top!</strong> This ensures our black screen covers the map.
            </div>
        </div>

        <!-- Slide 10: Removing from Tree -->
        <div class="slide">
            <h1>Suspending the Transition Scene</h1>
            <h2>Removing from Node Tree</h2>
            <div class="code-showcase">
var root_window : Window

func _ready() -> void:
    root_window = get_tree().root
    root_window.remove_child.call_deferred(self)

func play_exit_map() -> void:
    root_window.add_child(self)  # Add back to tree

func play_enter_map() -> void:
    root_window.remove_child(self)  # Remove from tree
            </div>
            <div class="demo-box">
                <p><strong>Why store root_window?</strong> Node isn't in tree when removed, so get_tree() won't work!</p>
            </div>
        </div>

        <!-- Slide 11: Creating Animations -->
        <div class="slide">
            <h1>Animation Setup</h1>
            <h2>Creating Fade Effects</h2>
            <div class="demo-box">
                <p><strong>Exit Map Animation (1 second):</strong></p>
                <ul style="text-align: left; margin: 20px;">
                    <li>FadeRect alpha: 0 ‚Üí 1 (fade in)</li>
                    <li>LeftSideRect scale X: 0 ‚Üí 1 (curtain close)</li>
                    <li>RightSideRect scale X: 0 ‚Üí -1 (curtain close)</li>
                </ul>
                <p><strong>Enter Map Animation (reverse):</strong></p>
                <ul style="text-align: left; margin: 20px;">
                    <li>Fade out and open curtains</li>
                </ul>
            </div>
            <p>Use AnimationPlayer's keyframe system to animate color and scale properties</p>
        </div>

        <!-- Slide 12: Playing Animations -->
        <div class="slide">
            <h1>Playing the Animations</h1>
            <h2>Hooking Up the AnimationPlayer</h2>
            <div class="code-showcase">
extends Node

@export var animation_player : AnimationPlayer
var root_window : Window

func play_exit_map() -> void:
    root_window.add_child(self)
    animation_player.play("exit_map")

func play_enter_map() -> void:
    animation_player.play("enter_map")
    root_window.remove_child(self)
            </div>
            <div class="godot-tip">
                <strong>Remember:</strong> Hook up the AnimationPlayer in the Inspector!
            </div>
        </div>

        <!-- Slide 13: Coroutines Introduction -->
        <div class="slide">
            <h1>Coroutines</h1>
            <h2>Functions That Can Pause</h2>
            <div class="concept-grid">
                <div class="concept-card">
                    <h3>üîÑ What are Coroutines?</h3>
                    <p>Functions that can be paused mid-execution and resumed later</p>
                </div>
                <div class="concept-card">
                    <h3>‚è∏Ô∏è The await Keyword</h3>
                    <p>Pauses execution until a signal or condition is met</p>
                </div>
                <div class="concept-card">
                    <h3>üéØ Use Cases</h3>
                    <p>Waiting for animations, timers, signals, or async operations</p>
                </div>
                <div class="concept-card">
                    <h3>‚ö° Power</h3>
                    <p>Write sequential code that waits without blocking the game</p>
                </div>
            </div>
        </div>

        <!-- Slide 14: Await Keyword -->
        <div class="slide">
            <h1>Using await</h1>
            <h2>Waiting for Animation to Finish</h2>
            <div class="code-showcase">
func play_exit_map() -> void:
    root_window.add_child(self)
    animation_player.play("exit_map")
    await animation_player.animation_finished  # Wait here!

func play_enter_map() -> void:
    animation_player.play("enter_map")
    await animation_player.animation_finished  # Wait here!
    root_window.remove_child(self)
            </div>
            <div class="demo-box">
                <p><strong>What happens:</strong> Function pauses at await, Godot continues running, resumes after signal fires</p>
            </div>
        </div>

        <!-- Slide 15: Chaining Awaits -->
        <div class="slide">
            <h1>Chaining Coroutines</h1>
            <h2>Await in Main.gd</h2>
            <div class="code-showcase">
func load_next_map() -> void:
    var current_map_path := get_tree().current_scene.scene_file_path
    # ... calculate next_map_path ...
    
    ResourceLoader.load_threaded_request(next_map_path)
    
    await MapTransition.play_exit_map()  # Wait for exit
    
    get_tree().change_scene_to_packed(
        ResourceLoader.load_threaded_get(next_map_path)
    )
    
    await MapTransition.play_enter_map()  # Wait for enter
            </div>
            <p>Coroutines can await other coroutines, creating a chain of sequential async operations</p>
        </div>

        <!-- Slide 16: Pausing the Game -->
        <div class="slide">
            <h1>Pausing During Transitions</h1>
            <h2>Preventing Player Input</h2>
            <div class="code-showcase">
func load_next_map() -> void:
    # ...
    
    get_tree().paused = true  # Pause the game
    await MapTransition.play_exit_map()
    
    get_tree().change_scene_to_packed(...)
    
    await MapTransition.play_enter_map()
    get_tree().paused = false  # Unpause the game
            </div>
            <div class="godot-tip">
                <strong>Problem:</strong> This pauses EVERYTHING, including our animations!
            </div>
        </div>

        <!-- Slide 17: Process Mode -->
        <div class="slide">
            <h1>Always Process Mode</h1>
            <h2>Ignoring Pause State</h2>
            <div class="demo-box">
                <p><strong>Solution:</strong> Set transition scene's Process Mode to "Always"</p>
                <ul style="text-align: left; margin: 20px;">
                    <li>Select transition scene root node</li>
                    <li>In Inspector: Node ‚Üí Process ‚Üí Mode</li>
                    <li>Set to "Always"</li>
                    <li>Scene will process even when game is paused</li>
                </ul>
            </div>
            <p>This allows animations to play during the pause!</p>
        </div>

        <!-- Slide 18: Threaded Loading -->
        <div class="slide">
            <h1>Threaded Resource Loading</h1>
            <h2>Performance Optimization</h2>
            <div class="code-showcase">
# Start loading in background
ResourceLoader.load_threaded_request(next_map_path)

get_tree().paused = true
await MapTransition.play_exit_map()  # Load during animation!

# Get the loaded resource (waits if not ready)
get_tree().change_scene_to_packed(
    ResourceLoader.load_threaded_get(next_map_path)
)
            </div>
            <div class="demo-box">
                <p><strong>Benefit:</strong> Next map loads while exit animation plays, minimizing wait time!</p>
            </div>
        </div>

        <!-- Slide 19: Before and After -->
        <div class="slide">
            <h1>Before and After</h1>
            <h2>Map Transition Improvements</h2>
            <div class="animation-example">
                <div class="animation-box" style="background: #ffcccc;">
                    <h3>Before ‚ùå</h3>
                    <ul style="text-align: left;">
                        <li>Instant scene change</li>
                        <li>No visual feedback</li>
                        <li>Jarring experience</li>
                        <li>Logic in map scene</li>
                    </ul>
                </div>
                <div class="animation-box" style="background: #ccffcc;">
                    <h3>After ‚úÖ</h3>
                    <ul style="text-align: left;">
                        <li>Smooth fade animation</li>
                        <li>Curtain effect</li>
                        <li>Pauses gameplay</li>
                        <li>Centralized management</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Slide 20: Key Concepts Review -->
        <div class="slide">
            <h1>Key Concepts</h1>
            <h2>What We Learned</h2>
            <div class="concept-grid">
                <div class="concept-card">
                    <h3>üåç Autoload</h3>
                    <p>Global scripts that persist across scenes</p>
                </div>
                <div class="concept-card">
                    <h3>üé≠ Transitions</h3>
                    <p>Scenes with animations for smooth map changes</p>
                </div>
                <div class="concept-card">
                    <h3>‚è∏Ô∏è Coroutines</h3>
                    <p>Functions that can await signals and resume</p>
                </div>
                <div class="concept-card">
                    <h3>‚ö° Threading</h3>
                    <p>Load resources in background for better performance</p>
                </div>
            </div>
        </div>

        <!-- Slide 21: Practical Tips -->
        <div class="slide">
            <h1>Godot Best Practices</h1>
            <h2>Tips for Transitions</h2>
            <div class="demo-box">
                <ul style="text-align: left; font-size: 1.2em; line-height: 2;">
                    <li>üéØ Use CanvasLayer to control draw order</li>
                    <li>üéØ Store references before removing from tree</li>
                    <li>üéØ Set Process Mode to Always for paused scenes</li>
                    <li>üéØ Chain coroutines with await for sequential operations</li>
                    <li>üéØ Start loading early with threaded requests</li>
                    <li>üéØ Use PascalCase for autoload node names</li>
                </ul>
            </div>
        </div>

        <!-- Slide 22: Common Pitfalls -->
        <div class="slide">
            <h1>Common Mistakes</h1>
            <h2>Watch Out For These!</h2>
            <div class="concept-grid">
                <div class="concept-card" style="border-color: #ff4444;">
                    <h3>‚ùå Forgetting await</h3>
                    <p>Code continues immediately instead of waiting for animation</p>
                </div>
                <div class="concept-card" style="border-color: #ff4444;">
                    <h3>‚ùå Using get_tree()</h3>
                    <p>Fails when node is removed from tree - store root reference!</p>
                </div>
                <div class="concept-card" style="border-color: #ff4444;">
                    <h3>‚ùå Wrong layer order</h3>
                    <p>Transition draws under map instead of over it</p>
                </div>
                <div class="concept-card" style="border-color: #ff4444;">
                    <h3>‚ùå Pausing animations</h3>
                    <p>Forgetting to set Process Mode to Always</p>
                </div>
            </div>
        </div>

        <!-- Slide 23: Extension Ideas -->
        <div class="slide">
            <h1>Taking It Further</h1>
            <h2>Enhancement Ideas</h2>
            <div class="demo-box">
                <ul style="text-align: left; font-size: 1.3em; line-height: 2;">
                    <li>üé® Add different transition styles (wipe, circle, etc.)</li>
                    <li>üîä Play transition sound effects</li>
                    <li>‚è±Ô∏è Show loading progress bar</li>
                    <li>üíæ Save/load game state during transition</li>
                    <li>üé≠ Direction-based transitions (left/right/up/down)</li>
                    <li>‚ú® Particle effects during transition</li>
                </ul>
            </div>
        </div>

        <!-- Slide 24: Source Material -->
        <div class="slide">
            <h1>Source Material</h1>
            <h2>Catlike Coding Tutorial Series</h2>
            <div class="demo-box">
                <p><strong>This lecture is based on:</strong></p>
                <p style="font-size: 1.3em; margin: 20px;">
                    <a href="https://catlikecoding.com/godot/" target="_blank" class="resource-link">
                        Catlike Coding - Godot Tutorials
                    </a>
                </p>
                <p>Tutorial: "Map Transitions" (published 2025-04-30)</p>
                <p>Covers autoload, coroutines, and smooth scene transitions</p>
            </div>
            <div class="godot-tip">
                <strong>Note:</strong> Tutorial uses Godot 4.3 but concepts apply to all Godot 4.x versions
            </div>
        </div>

        <!-- Slide 25: Summary -->
        <div class="slide">
            <h1>Achievement Unlocked! <span class="emoji">üèÜ</span></h1>
            <h2>Skills Acquired:</h2>
            <ul style="font-size: 1.3em; line-height: 2;">
                <li>‚úÖ Create and configure autoload scripts</li>
                <li>‚úÖ Build transition scenes with animations</li>
                <li>‚úÖ Use coroutines and await for async operations</li>
                <li>‚úÖ Manage game pause state</li>
                <li>‚úÖ Optimize with threaded resource loading</li>
            </ul>
            
            <div class="demo-box">
                <p><strong>Next Quest:</strong> Saving Progress - persistent game state</p>
                <p><strong>Homework:</strong> Continue working on your game project</p>
            </div>
        </div>

        <!-- Navigation Controls -->
        <div class="navigation">
            <button id="prevBtn">Previous</button>
            <span class="slide-counter">
                <span id="currentSlide">1</span> / <span id="totalSlides">25</span>
            </span>
            <button id="nextBtn">Next</button>
        </div>
    </div>

    <!-- Shared Presentation JavaScript -->
    <script src="../../js/presentation.js"></script>

    <!-- Lecture-Specific JavaScript -->
    <script>
        // Listen for slide changes
        document.addEventListener('slidechange', (e) => {
            console.log(`Slide ${e.detail.currentSlide + 1} of ${e.detail.totalSlides}`);
            
            // Could add slide-specific interactions here
            if (e.detail.currentSlide === 12) {
                console.log('Discussing coroutines - key concept!');
            }
        });
    </script>
</body>
</html>