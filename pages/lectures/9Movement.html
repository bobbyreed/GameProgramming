<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Session 9: Movement & Boundaries - CSCI 3213</title>
    
    <!-- OCU Branded Presentation Styles with Theme Support -->
    <link rel="stylesheet" href="../../styles/presentation.css">
    <link rel="icon" type="image/x-icon" href="/images/favicon.png">
    
    <!-- Lecture-Specific Styles -->
    <style>
        .movement-demo {
            background: #1a1a2e;
            color: #0f0;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            border: 2px solid #16213e;
            min-height: 300px;
            position: relative;
        }
        
        .movement-types {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .movement-card {
            background: var(--card-bg, #f8f8f8);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #00a8ff;
        }
        
        .boundary-visual {
            border: 3px dashed #ff4444;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            background: rgba(255, 68, 68, 0.1);
        }
        
        .interactive-canvas {
            border: 2px solid #333;
            border-radius: 8px;
            display: block;
            margin: 20px auto;
            background: #000;
        }
        
        .control-panel {
            background: var(--card-bg, #f8f8f8);
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        .vector-diagram {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 20px 0;
            font-size: 1.2em;
        }
        
        .physics-formula {
            background: #f0f8ff;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
            font-family: 'Courier New', monospace;
            font-size: 1.3em;
            color: #000;
        }
    </style>
</head>
<body>
    <!-- Theme toggle will be automatically added by JavaScript -->
    
    <div class="presentation-container">
        <!-- Timer display for activities -->
        <div class="timer-display" id="timer-display">
            <span id="timer-text">Session 9: Movement & Boundaries
                 <button class="home"><a href="../index.html">Home</a></button>
            </span>
        </div>

        <!-- Slide 1: Title -->
        <div class="slide active">
            <h1>Movement & Boundaries</h1>
            <h2>Creating Smooth, Controlled Motion <span class="emoji">üèÉ‚Äç‚ôÇÔ∏è</span></h2>
            <p style="font-size: 1.5em; margin-top: 40px;">CSCI 3213 - Game Programming</p>
            <p style="font-size: 1.3em;">Spring '26 - Week 9</p>
            <p style="margin-top: auto; font-style: italic;">From static to dynamic - let's get things moving!</p>
        </div>

        <!-- Slide 2: Learning Objectives -->
        <div class="slide">
            <h1>Today's Quest Objectives</h1>
            <ul style="font-size: 1.4em; line-height: 2;">
                <li>üéØ Implement smooth character movement</li>
                <li>‚ö° Apply velocity and acceleration concepts</li>
                <li>üöß Create boundary constraints</li>
                <li>üí• Handle collision with screen edges</li>
                <li>üé® Build different movement patterns</li>
            </ul>
            
            <div class="tip-box" style="margin-top: 30px;">
                <strong>Core Concept:</strong> Movement is the foundation of game feel - it needs to be responsive, predictable, and satisfying!
            </div>
        </div>

        <!-- Slide 3: Physics Fundamentals -->
        <div class="slide">
            <h1>Movement Physics 101</h1>
            
            <div class="physics-formula">
                position = position + (velocity √ó deltaTime)
            </div>
            
            <div class="physics-formula">
                velocity = velocity + (acceleration √ó deltaTime)
            </div>
            
            <div class="demo-box">
                <h3>Key Concepts:</h3>
                <ul>
                    <li><strong>Position:</strong> Where the object is (x, y coordinates)</li>
                    <li><strong>Velocity:</strong> How fast and in what direction it's moving</li>
                    <li><strong>Acceleration:</strong> How velocity changes over time</li>
                    <li><strong>Delta Time:</strong> Time since last frame (smooth movement)</li>
                </ul>
            </div>
        </div>

        <!-- Slide 4: Basic Movement Implementation -->
        <div class="slide">
            <h1>Implementing Basic Movement</h1>
            
            <div class="code-example">
                <span class="comment">// Player object with position and velocity</span>
                <span class="keyword">var</span> player = {
                    position: { x: <span class="number">100</span>, y: <span class="number">100</span> },
                    velocity: { x: <span class="number">0</span>, y: <span class="number">0</span> },
                    speed: <span class="number">5</span>
                };

                <span class="comment">// Update function called every frame</span>
                <span class="keyword">function</span> <span class="function">update</span>(deltaTime) {
                    <span class="comment">// Apply velocity to position</span>
                    player.position.x += player.velocity.x * deltaTime;
                    player.position.y += player.velocity.y * deltaTime;
                }

                <span class="comment">// Handle keyboard input</span>
                <span class="keyword">if</span> (keys.left) {
                    player.velocity.x = -player.speed;
                }
            </div>
        </div>

        <!-- Slide 5: Boundary Mathematics -->
        <div class="slide">
            <h1>Boundary Constraints</h1>
            
            <h2>The Clamping Pattern</h2>
            <div class="code-example">
                <span class="comment">// Clamp function - keeps value within bounds</span>
                <span class="keyword">function</span> <span class="function">clamp</span>(value, min, max) {
                    <span class="keyword">return</span> Math.<span class="function">min</span>(Math.<span class="function">max</span>(value, min), max);
                }

                <span class="comment">// Apply boundaries to player position</span>
                player.position.x = <span class="function">clamp</span>(
                    player.position.x, 
                    <span class="number">0</span>, 
                    canvas.width - player.width
                );
                
                player.position.y = <span class="function">clamp</span>(
                    player.position.y, 
                    <span class="number">0</span>, 
                    canvas.height - player.height
                );
            </div>
            
            <div class="tip-box">
                <strong>Pro Tip:</strong> Always account for entity size when setting boundaries!
            </div>
        </div>

        <!-- Slide 6: Boundary Behaviors -->
        <div class="slide">
            <h1>Three Boundary Behaviors</h1>
            
            <div class="movement-types">
                <div class="movement-card">
                    <h3>üõë Stop at Edge</h3>
                    <div class="code-example" style="font-size: 0.9em;">
                        <span class="keyword">if</span> (x > maxX) {
                            x = maxX;
                            velocity.x = <span class="number">0</span>;
                        }
                    </div>
                </div>
                
                <div class="movement-card">
                    <h3>üîÑ Wrap Around</h3>
                    <div class="code-example" style="font-size: 0.9em;">
                        <span class="keyword">if</span> (x > maxX) {
                            x = <span class="number">0</span>;
                        }
                        <span class="keyword">if</span> (x < <span class="number">0</span>) {
                            x = maxX;
                        }
                    </div>
                </div>
                
                <div class="movement-card">
                    <h3>‚ö° Bounce</h3>
                    <div class="code-example" style="font-size: 0.9em;">
                        <span class="keyword">if</span> (x > maxX || x < <span class="number">0</span>) {
                            velocity.x *= <span class="number">-1</span>;
                        }
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 7: Movement Types -->
        <div class="slide">
            <h1>Movement Patterns</h1>
            
            <div class="movement-types">
                <div class="movement-card">
                    <h3>Instant Movement</h3>
                    <p>Direct position change</p>
                    <code>position.x = targetX;</code>
                </div>
                
                <div class="movement-card">
                    <h3>Linear Movement</h3>
                    <p>Constant velocity</p>
                    <code>position += velocity;</code>
                </div>
                
                <div class="movement-card">
                    <h3>Acceleration-based</h3>
                    <p>Gradual speed changes</p>
                    <code>velocity += acceleration;</code>
                </div>
                
                <div class="movement-card">
                    <h3>Grid-based</h3>
                    <p>Fixed step movement</p>
                    <code>x += gridSize;</code>
                </div>
            </div>
            
            <div class="demo-box">
                <strong>Game Examples:</strong> Instant (Chess), Linear (Pac-Man), Acceleration (Racing), Grid (Tetris)
            </div>
        </div>

        <!-- Slide 8: Advanced Techniques -->
        <div class="slide">
            <h1>Smooth Movement Techniques</h1>
            
            <h2>Linear Interpolation (Lerp)</h2>
            <div class="code-example">
                <span class="keyword">function</span> <span class="function">lerp</span>(start, end, amount) {
                    <span class="keyword">return</span> start + (end - start) * amount;
                }

                <span class="comment">// Smooth camera follow</span>
                camera.x = <span class="function">lerp</span>(camera.x, player.x, <span class="number">0.1</span>);
            </div>
            
            <h2>Acceleration & Friction</h2>
            <div class="code-example">
                <span class="comment">// Apply acceleration</span>
                <span class="keyword">if</span> (keys.right) velocity.x += acceleration;
                
                <span class="comment">// Apply friction</span>
                velocity.x *= <span class="number">0.9</span>; <span class="comment">// 10% reduction per frame</span>
            </div>
        </div>

        <!-- Slide 9: Exercise 1 - Movement Styles -->
        <div class="slide">
            <h1>Exercise 1: Movement Styles</h1>
            <h2>Implement Three Movement Types (15 mins)</h2>
            
            <div class="exercise-box">
                <h3>Your Task:</h3>
                <ol>
                    <li>Create a player object that can switch between:
                        <ul>
                            <li>Instant teleport movement (press 1)</li>
                            <li>Smooth acceleration-based movement (press 2)</li>
                            <li>Grid-based movement (press 3)</li>
                        </ul>
                    </li>
                    <li>Use arrow keys for direction</li>
                    <li>Display current movement type on screen</li>
                </ol>
                
                <div class="code-hint">
                    <strong>Starter Code:</strong>
                    <pre>var player = {
    x: 250, y: 250,
    vx: 0, vy: 0,
    moveType: 'instant',
    gridSize: 32
};</pre>
                </div>
            </div>
        </div>

        <!-- Slide 10: Exercise 2 - Boundary Behaviors -->
        <div class="slide">
            <h1>Exercise 2: Boundary Behaviors</h1>
            <h2>Create Different Edge Responses (15 mins)</h2>
            
            <div class="exercise-box">
                <h3>Your Task:</h3>
                <p>Create three objects that handle boundaries differently:</p>
                
                <div class="movement-types">
                    <div class="movement-card">
                        <h4>Red Square</h4>
                        <p>Stops at edges</p>
                    </div>
                    <div class="movement-card">
                        <h4>Green Circle</h4>
                        <p>Wraps around to opposite side</p>
                    </div>
                    <div class="movement-card">
                        <h4>Blue Triangle</h4>
                        <p>Bounces off walls</p>
                    </div>
                </div>
                
                <div class="tip-box">
                    <strong>Hint:</strong> Use different colors and shapes to make behaviors visually distinct!
                </div>
            </div>
        </div>

        <!-- Slide 11: Exercise 3 - Movement Trail -->
        <div class="slide">
            <h1>Exercise 3: Movement Trail</h1>
            <h2>Visual Motion History (15 mins)</h2>
            
            <div class="exercise-box">
                <h3>Create a Trail Effect:</h3>
                <ol>
                    <li>Store last 20 positions of the player</li>
                    <li>Draw trail with decreasing opacity</li>
                    <li>Make trail color change based on speed</li>
                </ol>
                
                <div class="code-example">
                    <span class="comment">// Trail system starter</span>
                    <span class="keyword">var</span> trail = [];
                    <span class="keyword">var</span> maxTrailLength = <span class="number">20</span>;
                    
                    <span class="keyword">function</span> <span class="function">updateTrail</span>(x, y) {
                        trail.<span class="function">push</span>({x: x, y: y});
                        <span class="keyword">if</span> (trail.length > maxTrailLength) {
                            trail.<span class="function">shift</span>();
                        }
                    }
                </div>
            </div>
        </div>

        <!-- Slide 12: Bengston Engine Implementation -->
        <div class="slide">
            <h1>Real Engine Example</h1>
            <h2>Bengston Engine Boundary System</h2>
            
            <div class="code-example">
                <span class="comment">// Extending Number prototype for clean syntax</span>
                Number.prototype.boundary = <span class="keyword">function</span>(min, max) {
                    <span class="keyword">return</span> Math.<span class="function">min</span>(Math.<span class="function">max</span>(<span class="keyword">this</span>, min), max);
                };

                <span class="comment">// Clean usage in player update</span>
                player.update = <span class="keyword">function</span>() {
                    <span class="comment">// Update position based on input</span>
                    <span class="keyword">if</span> (keys.left) player.x -= player.speed;
                    <span class="keyword">if</span> (keys.right) player.x += player.speed;
                    
                    <span class="comment">// Apply boundaries elegantly</span>
                    player.x = player.x.<span class="function">boundary</span>(<span class="number">0</span>, canvas.width - player.width);
                    player.y = player.y.<span class="function">boundary</span>(<span class="number">0</span>, canvas.height - player.height);
                };
            </div>
            
            <div class="tip-box">
                <strong>Design Pattern:</strong> This prototype extension makes boundary checking readable and reusable!
            </div>
        </div>

        <!-- Slide 13: Common Pitfalls -->
        <div class="slide">
            <h1>Common Movement Bugs</h1>
            
            <div class="bug-list">
                <h3>‚ö†Ô∏è Watch Out For:</h3>
                <ul style="font-size: 1.3em; line-height: 1.8;">
                    <li><strong>Diagonal Speed:</strong> Moving diagonally is ‚àö2 times faster
                        <div class="code-hint">Solution: Normalize diagonal vectors</div>
                    </li>
                    <li><strong>Frame Rate Dependence:</strong> Movement speed varies with FPS
                        <div class="code-hint">Solution: Always use deltaTime</div>
                    </li>
                    <li><strong>Boundary Overshoot:</strong> Object clips through boundaries
                        <div class="code-hint">Solution: Check boundaries AFTER movement</div>
                    </li>
                    <li><strong>Jittery Movement:</strong> Rounding errors cause shaking
                        <div class="code-hint">Solution: Use floating point for position, round only when rendering</div>
                    </li>
                </ul>
            </div>
        </div>

        <!-- Slide 14: Performance Tips -->
        <div class="slide">
            <h1>Optimization Strategies</h1>
            
            <div class="demo-box">
                <h3>Performance Best Practices:</h3>
                <ul style="font-size: 1.2em;">
                    <li>Cache boundary values instead of recalculating</li>
                    <li>Use squared distances to avoid sqrt() calculations</li>
                    <li>Implement spatial partitioning for many objects</li>
                    <li>Only update what's visible on screen</li>
                </ul>
            </div>
            
            <div class="code-example">
                <span class="comment">// Cache calculations</span>
                <span class="keyword">var</span> maxX = canvas.width - player.width;
                <span class="keyword">var</span> maxY = canvas.height - player.height;

                <span class="comment">// Avoid sqrt for distance checks</span>
                <span class="keyword">var</span> distanceSquared = dx * dx + dy * dy;
                <span class="keyword">if</span> (distanceSquared < radiusSquared) {
                    <span class="comment">// Collision!</span>
                }
            </div>
        </div>

        <!-- Slide 15: Quick Reference -->
        <div class="slide">
            <h1>Movement Formula Cheat Sheet</h1>
            
            <div class="reference-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <div class="formula-card">
                    <h3>Linear Movement</h3>
                    <code>pos += vel * dt</code>
                </div>
                
                <div class="formula-card">
                    <h3>Acceleration</h3>
                    <code>vel += acc * dt</code>
                </div>
                
                <div class="formula-card">
                    <h3>Friction</h3>
                    <code>vel *= friction</code>
                </div>
                
                <div class="formula-card">
                    <h3>Clamping</h3>
                    <code>x = min(max(x, minX), maxX)</code>
                </div>
                
                <div class="formula-card">
                    <h3>Wrapping</h3>
                    <code>x = x % maxX</code>
                </div>
                
                <div class="formula-card">
                    <h3>Bounce</h3>
                    <code>vel *= -damping</code>
                </div>
                
                <div class="formula-card">
                    <h3>Lerp</h3>
                    <code>a + (b - a) * t</code>
                </div>
                
                <div class="formula-card">
                    <h3>Normalize</h3>
                    <code>vec / length(vec)</code>
                </div>
            </div>
        </div>

        <!-- Slide 16: Summary & Next Steps -->
        <div class="slide">
            <h1>Session Complete! <span class="emoji">üèÜ</span></h1>
            <h2>Skills Unlocked:</h2>
            <ul style="font-size: 1.3em;">
                <li>‚úÖ Implemented smooth character movement</li>
                <li>‚úÖ Applied velocity and acceleration</li>
                <li>‚úÖ Created boundary constraints</li>
                <li>‚úÖ Built multiple movement patterns</li>
                <li>‚úÖ Handled edge collision behaviors</li>
            </ul>
            
            <div class="demo-box" style="margin-top: 30px;">
                <p><strong>Homework:</strong> Combine all three exercises into one game where the player can switch between movement modes and boundary behaviors</p>
                <p><strong>Next Session:</strong> Integration & Polish - Bringing it all together!</p>
                <p><strong>Challenge:</strong> Add a "ghost mode" that phases through boundaries temporarily</p>
            </div>
        </div>

        <!-- Navigation Controls -->
        <div class="navigation">
            <button id="prevBtn">Previous</button>
            <span class="slide-counter">
                <span id="currentSlide">1</span> / <span id="totalSlides">16</span>
            </span>
            <button id="nextBtn">Next</button>
        </div>
    </div>

    <!-- Shared Presentation JavaScript -->
    <script src="../../js/presentation.js"></script>

    <!-- Lecture-Specific JavaScript -->
    <script>
        // Movement demo for slide interaction
        let demoCanvas = null;
        let demoContext = null;
        let demoPlayer = {
            x: 50, y: 50,
            vx: 0, vy: 0,
            size: 20,
            color: '#00ff00'
        };

        // Listen for slide changes to trigger demos
        document.addEventListener('slidechange', (e) => {
            console.log(`Slide ${e.detail.currentSlide + 1} - Movement & Boundaries`);
            
            // Initialize canvas demo on specific slides
            if (e.detail.currentSlide === 8) { // Exercise 1
                console.log('Ready for Movement Styles exercise');
                initMovementDemo();
            } else if (e.detail.currentSlide === 9) { // Exercise 2
                console.log('Ready for Boundary Behaviors exercise');
            } else if (e.detail.currentSlide === 10) { // Exercise 3
                console.log('Ready for Movement Trail exercise');
            }
        });

        // Timer for exercises
        function startExerciseTimer(minutes) {
            let seconds = minutes * 60;
            const timerDisplay = document.getElementById('timer-text');
            const originalText = timerDisplay.textContent;
            
            const timer = setInterval(() => {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                timerDisplay.textContent = `Time Remaining: ${mins}:${secs.toString().padStart(2, '0')}`;
                
                seconds--;
                
                if (seconds < 0) {
                    clearInterval(timer);
                    timerDisplay.textContent = originalText;
                    alert('Time\'s up! Let\'s review the solution.');
                }
            }, 1000);
            
            return timer;
        }

        // Simple movement demo initialization
        function initMovementDemo() {
            // This would create a small interactive canvas for testing
            console.log('Movement demo ready - students can test their code here');
        }

        // Helper function for boundary clamping (available to students)
        function clamp(value, min, max) {
            return Math.min(Math.max(value, min), max);
        }

        // Example trail system for students
        class TrailSystem {
            constructor(maxLength = 20) {
                this.positions = [];
                this.maxLength = maxLength;
            }
            
            addPosition(x, y) {
                this.positions.push({x, y, time: Date.now()});
                if (this.positions.length > this.maxLength) {
                    this.positions.shift();
                }
            }
            
            draw(ctx) {
                this.positions.forEach((pos, index) => {
                    const opacity = index / this.positions.length;
                    ctx.fillStyle = `rgba(255, 255, 255, ${opacity * 0.5})`;
                    ctx.fillRect(pos.x, pos.y, 5, 5);
                });
            }
        }

        // Log when lecture loads
        console.log('Session 9: Movement & Boundaries - Ready!');
        console.log('Available helpers: clamp(), TrailSystem class');
    </script>
</body>
</html>